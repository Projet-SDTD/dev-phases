import base64
import sys
import numpy as np
import onnx
import os
import glob
import onnxruntime
from cassandra.cluster import Cluster
from PIL import Image
from kafka import KafkaConsumer
from json import loads

from onnx import numpy_helper
from enum import Enum

try:
    import cv2
except ImportError:
    sys.stderr.write("This example requires opencv-python is installed")
    raise

class Emotions(Enum):
    NEUTRAL = 0
    HAPPINESS = 1
    SURPRISE = 2
    SADNESS = 3
    ANGER = 4
    DISGUST = 5
    FEAR = 6
    CONTEMPT = 7

def preprocess(image):
  input_shape = (1, 1, 64, 64)
  img = image.convert('L')
  img = img.resize((64, 64), Image.Resampling.LANCZOS)
  img_data = np.array(img, dtype=np.float32)
  
  img_data = np.resize(img_data, input_shape)
  return img_data

def softmax(x):
    e_x = np.exp(x - np.max(x))
    return e_x / e_x.sum()

def postprocess(scores):
    '''
    This function takes the scores generated by the network and returns the class IDs in decreasing
    order of probability.
    '''
    prob = softmax(scores)
    prob = np.squeeze(prob)
    classes = np.argsort(prob)[::-1]
    return classes

def check_model():
    test_data_dir = 'test_data_set_0'
    inputs_num = 1
    # Load inputs
    inputs = []
    for i in range(inputs_num):
        input_file = os.path.join(test_data_dir, 'input_{}.pb'.format(i))
        tensor = onnx.TensorProto()
        with open(input_file, 'rb') as f:
            tensor.ParseFromString(f.read())
            inputs.append(numpy_helper.to_array(tensor))

    # Load reference outputs
    ref_outputs = []
    ref_outputs_num = 1
    for i in range(ref_outputs_num):
        output_file = os.path.join(test_data_dir, 'output_{}.pb'.format(i))
        tensor = onnx.TensorProto()
        with open(output_file, 'rb') as f:
            tensor.ParseFromString(f.read())
            ref_outputs.append(numpy_helper.to_array(tensor))

    # Run the model on the backend
    EP_list = ['CPUExecutionProvider']
    session = onnxruntime.InferenceSession("emotion-ferplus-8.onnx", providers=EP_list)
    input_name = session.get_inputs()[0].name
    #print('Input Name:', input_name)
    outputs = [session.run([], {input_name: inputs[i]})[0] for i in range(inputs_num)]

    #print('Predicted {} results.'.format(len(outputs)))

    # Compare the results with reference outputs up to 4 decimal places
    for ref_o, o in zip(ref_outputs, outputs):
        np.testing.assert_almost_equal(ref_o, o, 4)
        
    #print('ONNX Runtime outputs are similar to reference outputs!')

def main(kafka_url = "kafka-svc:9092", cassandra_url = "cassandra"):
    #check_model()
    EP_list = ['CPUExecutionProvider']
    session = onnxruntime.InferenceSession("emotion-ferplus-8.onnx", providers=EP_list)
    input_name = session.get_inputs()[0].name
    print("Connecting to kafka...")
    kafka_consumer = KafkaConsumer(  
        'phase2',
        api_version = (3,3,1),
        security_protocol= "PLAINTEXT",
        bootstrap_servers = kafka_url,
        auto_offset_reset = 'earliest',  
        enable_auto_commit = True,
        group_id = 'my-group',  
        value_deserializer = lambda x : loads(x.decode('utf-8'))  
    )
    print("Connected !")
    print("Connecting to Cassandra...")
    cluster = Cluster([cassandra_url], port=9042)
    session_cassandra = cluster.connect("stream_db", wait_for_all_pools=True)
    session_cassandra.set_keyspace("stream_db")
    print("Connected !")
    #faces_data = open("faces_data.txt", "r")
    #lines = faces_data.readlines()
    

    for message in kafka_consumer:
        message = message.value
        frame_number = message['frame_number']
        print(frame_number)
        #emotion_res = open(f"emotion_res_{frame_number}.txt", "w+")

        img = base64.b64decode(message['frame'])
        img_buffer = np.array(cv2.imdecode(np.frombuffer(img, dtype=np.uint8) , flags=1))
        #print(img_buffer.shape)
        all_faces = message['detected_faces']
        img = Image.fromarray(img_buffer.astype('uint8'), 'RGB')
        #print(all_faces)
        #emotion_res.write(f"{frame_number}.jpg ")
        res = ""
        for index, face in enumerate(all_faces):
            x = face[0]
            y = face[1]
            w = face[2]
            h = face[3]
            area = (x, y, x + w, y + h)
            cropped_img = img.crop(area)

            data = preprocess(cropped_img)

            raw_res = session.run([], {input_name: data})
            classes = postprocess(raw_res)
            res += f"; {x}_{y}_{w}_{h} = "
            for elem in classes:
                res += f"{Emotions(elem).name} "
            #print("len : ", len(classes))
            if(len(classes) > 0):
                #print("inserting...")
                session_cassandra.execute(
                    """
                    INSERT INTO frames (frame_id, face_id, x, y, w, h, main_emotion) VALUES(%s, %s, %s, %s, %s, %s, %s)
                    """,
                    (frame_number, index, x, y, w, h, classes[0])
                )
            
        #emotion_res.write(f"{res}\n")
        #print(f"{res}\n")
        #emotion_res.close()

if __name__=="__main__":
    KAFKA_URL = os.getenv("KAFKA_URL")
    if(KAFKA_URL is None):
        KAFKA_URL = "kafka-svc:9092"
    CASSANDRA_URL = os.getenv("CASSANDRA_URL")
    if(CASSANDRA_URL is None):
        CASSANDRA_URL = "cassandra"
    main(KAFKA_URL, CASSANDRA_URL)


